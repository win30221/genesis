package llm

import (
	"encoding/base64"
	"fmt"
	"genesis/pkg/utils"
	"os"
	"strings"
	"time"
)

// Tool represents the minimal interface required for an LLM provider to
// understand and format a tool for its API.
type Tool interface {
	Name() string
	Description() string
	Parameters() map[string]any
	RequiredParameters() []string
}

// Message represents a single unit of conversation in a multi-modal chat history.
// It maps to common LLM interaction formats like OpenAI or Gemini messages,
// supporting roles, content blocks, and tool-related metadata.
type Message struct {
	// ID is a unique, time-sorted identifier for the message (e.g., ObjectID style).
	ID string `json:"id,omitempty"`
	// Role defines the author of the message: "user", "assistant", "system", or "tool".
	Role string `json:"role"`
	// Content contains an ordered slice of multimodel blocks (text, images, thinking, etc.).
	Content []ContentBlock `json:"content"`
	// Timestamp records the creation time of the message in Unix epoch format.
	Timestamp int64 `json:"timestamp,omitempty"`

	// ToolCalls contains a list of specific tool requests generated by the LLM.
	// This field is only valid when Role is "assistant".
	ToolCalls []ToolCall `json:"tool_calls,omitempty"`

	// ToolCallID links this message to a specific tool request if this message
	// contains a tool result. This field is only valid when Role is "tool".
	ToolCallID string `json:"tool_call_id,omitempty"`

	// ToolName is the name of the tool being called. Required for Gemini tool results.
	ToolName string `json:"tool_name,omitempty"`

	// Usage provides token metrics and termination metadata for this specific
	// exchange, typically populated for assistant responses.
	Usage *LLMUsage `json:"usage,omitempty"`
}

// ToolCall represents a specific request from the LLM to execute an external tool.
type ToolCall struct {
	// ID is the unique identifier provided by the LLM to track this specific call.
	ID string `json:"id"`
	// Name is the name of the tool intended to be called.
	Name string `json:"name"`
	// Function encapsulates the arguments and precise function details.
	Function FunctionCall `json:"function"`

	// ProviderMetadata optional metadata needed by the LLM provider to maintain
	// state across turns (e.g., Gemini thought signatures).
	ProviderMetadata map[string]any `json:"provider_metadata,omitempty"`

	// Meta holds internal, provider-specific fields (e.g., original SDK objects)
	// that are required for consecutive calls but not to be exposed to the user.
	Meta map[string]any `json:"-"`
}

// FunctionCall contains the low-level details of a tool call request.
type FunctionCall struct {
	// Name matches the tool name defined in the provider's tool schema.
	Name string `json:"name"`
	// Arguments is a JSON-encoded string representing the parameters for the tool.
	Arguments string `json:"arguments"`
}

// ContentBlock is an atomic unit of content within a Message.
// It abstracts different data formats like text, internal reasoning (thinking),
// errors, or multi-modal sources like images.
type ContentBlock struct {
	// Type specifies the content format: "text", "thinking", "error", or "image".
	Type string `json:"type"`

	// Text contains the string content for "text", "thinking", or "error" types.
	Text string `json:"text,omitempty"`

	// Source points to binary or remote data for "image" type blocks.
	Source *ImageSource `json:"source,omitempty"`
}

// ImageSource defines the raw data or reference for an image content block.
type ImageSource struct {
	// Type indicates the data format: "base64" (inline binary) or "url" (remote).
	Type string `json:"type"`
	// MediaType specifies the MIME type (e.g., "image/jpeg", "image/png").
	MediaType string `json:"media_type"`
	// Data holds the raw binary bytes for base64 type images (not serialized).
	Data []byte `json:"-"`
	// URL holds the address for remote image references.
	URL string `json:"url,omitempty"`
	// Path holds the local file system path for stored images.
	Path string `json:"path,omitempty"`
}

// MarshalJSON custom JSON serialization (converts Data to base64)
func (is *ImageSource) MarshalJSON() ([]byte, error) {
	type alias struct {
		Type      string `json:"type"`
		MediaType string `json:"media_type"`
		Data      string `json:"data,omitempty"`
		URL       string `json:"url,omitempty"`
		Path      string `json:"path,omitempty"`
	}
	a := alias{
		Type:      is.Type,
		MediaType: is.MediaType,
		URL:       is.URL,
		Path:      is.Path,
	}
	if is.Type == "base64" && len(is.Data) > 0 {
		a.Data = base64.StdEncoding.EncodeToString(is.Data)
	}
	return json.Marshal(a)
}

// UnmarshalJSON custom JSON deserialization (converts base64 back to Data)
func (is *ImageSource) UnmarshalJSON(data []byte) error {
	aux := &struct {
		DataBase64 string `json:"data"`
		Type       string `json:"type"`
		MediaType  string `json:"media_type"`
		URL        string `json:"url"`
		Path       string `json:"path"`
	}{}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	is.Type = aux.Type
	is.MediaType = aux.MediaType
	is.URL = aux.URL
	is.Path = aux.Path

	if aux.DataBase64 != "" {
		decoded, err := base64.StdEncoding.DecodeString(aux.DataBase64)
		if err != nil {
			return err
		}
		is.Data = decoded
	}

	return nil
}

// LoadData reads the image data from Path if type is "file" and hydrates the Data field.
// This is useful for UI contexts where local file paths are not accessible.
func (is *ImageSource) LoadData() error {
	if is.Type != "file" || is.Path == "" {
		return nil
	}

	data, err := os.ReadFile(is.Path)
	if err != nil {
		return fmt.Errorf("failed to load image data from %s: %w", is.Path, err)
	}

	is.Data = data
	is.Type = "base64"
	return nil
}

// StreamChunk represents a single, incremental fragment of an LLM streaming response.
// It allows the frontend and gateway to process content in real-time as it's
// generated by the provider.
type StreamChunk struct {
	// ContentBlocks contains newly generated content fragments (text, thinking).
	ContentBlocks []ContentBlock `json:"content_blocks,omitempty"`

	// ToolCalls contains incremental or complete tool request fragments.
	ToolCalls []ToolCall `json:"tool_calls,omitempty"`

	// IsFinal is true if this is the last chunk of the stream.
	IsFinal bool `json:"is_final"`

	// FinishReason provides context on why the generation ended (final chunk only).
	FinishReason string `json:"finish_reason,omitempty"`

	// Usage provides optional token metrics (typically in the final chunk).
	Usage *LLMUsage `json:"usage,omitempty"`

	// Error is a user-friendly error message if the stream was interrupted.
	Error string `json:"error,omitempty"`

	// RawError holds the original Go error for internal logging and retry logic.
	RawError error `json:"-"`
}

// NewTextMessage creates a Message with the specified role and a single text block.
func NewTextMessage(role, text string) Message {
	return Message{
		ID:   utils.GenerateID(),
		Role: role,
		Content: []ContentBlock{{
			Type: BlockTypeText,
			Text: text,
		}},
		Timestamp: time.Now().Unix(),
	}
}

// NewSystemMessage creates a Message specifically for the "system" role.
func NewSystemMessage(text string) Message {
	return NewTextMessage("system", text)
}

// NewUserMessage creates a Message specifically for the "user" role.
func NewUserMessage(text string) Message {
	return NewTextMessage("user", text)
}

// NewAssistantMessage creates a Message specifically for the "assistant" role.
func NewAssistantMessage(text string) Message {
	return NewTextMessage("assistant", text)
}

// AddContentBlock adds a content block to the message
func (m *Message) AddContentBlock(block ContentBlock) {
	m.Content = append(m.Content, block)
}

// GetTextContent aggregates and returns all text from "text" blocks in the message.
// It filters out thinking, image, or error blocks.
func (m *Message) GetTextContent() string {
	var sb strings.Builder
	for _, block := range m.Content {
		if block.Type == BlockTypeText {
			sb.WriteString(block.Text)
		}
	}
	return sb.String()
}

// GetThinkingContent aggregates and returns all text from "thinking" blocks.
func (m *Message) GetThinkingContent() string {
	var sb strings.Builder
	for _, block := range m.Content {
		if block.Type == BlockTypeThinking {
			sb.WriteString(block.Text)
		}
	}
	return sb.String()
}

// FilterBlocks filters blocks of a specified type
func (m *Message) FilterBlocks(blockType string) []ContentBlock {
	var filtered []ContentBlock
	for _, block := range m.Content {
		if block.Type == blockType {
			filtered = append(filtered, block)
		}
	}
	return filtered
}

// HasImages checks if the message contains images
func (m *Message) HasImages() bool {
	for _, block := range m.Content {
		if block.Type == BlockTypeImage {
			return true
		}
	}
	return false
}

// NewTextBlock creates a text block
func NewTextBlock(text string) ContentBlock {
	return ContentBlock{
		Type: BlockTypeText,
		Text: text,
	}
}

// NewThinkingBlock creates a thinking block
func NewThinkingBlock(text string) ContentBlock {
	return ContentBlock{
		Type: BlockTypeThinking,
		Text: text,
	}
}

// NewErrorBlock creates an error block
func NewErrorBlock(text string) ContentBlock {
	return ContentBlock{
		Type: BlockTypeError,
		Text: text,
	}
}

// NewImageBlock creates an image block (base64)
func NewImageBlock(data []byte, mimeType string) ContentBlock {
	return ContentBlock{
		Type: BlockTypeImage,
		Source: &ImageSource{
			Type:      "base64",
			MediaType: mimeType,
			Data:      data,
		},
	}
}

// NewImageBlockFromFile creates an image block linked to a local file
func NewImageBlockFromFile(path, mimeType string) ContentBlock {
	return ContentBlock{
		Type: BlockTypeImage,
		Source: &ImageSource{
			Type:      "file",
			MediaType: mimeType,
			Path:      path,
		},
	}
}

// NewImageBlockFromURL creates an image block (URL)
func NewImageBlockFromURL(url, mimeType string) ContentBlock {
	return ContentBlock{
		Type: BlockTypeImage,
		Source: &ImageSource{
			Type:      "url",
			MediaType: mimeType,
			URL:       url,
		},
	}
}

// NewTextChunk creates a StreamChunk initialized with a single text block.
func NewTextChunk(text string) StreamChunk {
	return StreamChunk{
		ContentBlocks: []ContentBlock{{
			Type: BlockTypeText,
			Text: text,
		}},
	}
}

// NewThinkingChunk creates a thinking chunk
func NewThinkingChunk(text string) StreamChunk {
	return StreamChunk{
		ContentBlocks: []ContentBlock{{
			Type: BlockTypeThinking,
			Text: text,
		}},
	}
}

// NewFinalChunk creates a final chunk (with usage statistics)
func NewFinalChunk(reason string, usage *LLMUsage) StreamChunk {
	if usage == nil {
		usage = &LLMUsage{}
	}
	usage.StopReason = reason
	return StreamChunk{
		IsFinal:      true,
		FinishReason: reason,
		Usage:        usage,
	}
}

// NewErrorChunk creates an error chunk (should not be added to history, displayed to user only)
func NewErrorChunk(errMsg string, rawErr error, isFinal bool) StreamChunk {
	return StreamChunk{
		Error:    errMsg,
		RawError: rawErr,
		IsFinal:  isFinal,
	}
}
